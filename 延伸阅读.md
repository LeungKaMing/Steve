## 关于webpack的splitChunkPlugin
> 有必要针对插件的chunks值做详细说明：什么模块会进行提取？
通过判断splitChunks.chunks的值来确定哪些模块会提取公共模块，该配置一共有三个选项，initial、async、 all。
默认为async，表示只会提取异步加载模块的公共代码，initial表示只会提取初始入口模块的公共代码，all表示同时提取前两者的代码。
```
//webpack.config.js
module.exports = {
  entry: {
    main: 'src/index.js'
  }
}

//index.js
import Vue from 'vue'
import(/* webpackChunkName: "asyncModule" */'./a.js')
  .then(mod => {
    console.log('loaded module a', mod)
  })

console.log('initial module')
new Vue({})

//a.js
import _ from 'lodash'
const obj = { name: 'module a' }
export default _.clone(obj)
```
- 上面的代码中，index.js在webpack的entry配置中，这是打包的入口，所以这个模块是初始入口模块。再看看index.js中使用了动态import语法，对a.js（该异步模块被命名为asyncModule）进行异步加载，则a.js就是一个异步加载模块。
- 再看看index.js和a.js都有来自node_modules的模块，按照之前的规则，splitChunks.chunks默认为async，所以会被提取到vendors中的只有webpackChunkName中的模块asyncModule。

## 关于.babelrc
该presets的值是从后往前，env转换es6，stage-0转es7

## vuex


## vue-router
### 响应路由参数的变化
1. 当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被【复用】。--因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效--。不过，这也【意味着组件的生命周期钩子不会再被调用】。
2. 想对路由参数的变化作出响应的话，除了可以用 watch (监测变化) $route 对象；还可以用beforeRouteUpdate 导航守卫。

### 编程式导航
除了使用[声明式]	 <router-link> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写[编程式]导航来实现。
- 使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。
- 当你点击 <router-link> 时，这个方法会在内部调用，所以说，点击 <router-link :to="..."> 等同于调用 router.push(...)。

### 重定向






